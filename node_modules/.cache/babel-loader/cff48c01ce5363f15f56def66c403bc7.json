{"ast":null,"code":"import \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.string.iterator.js\";\n\nfunction Random(_ref) {\n  var min = _ref.min,\n      max = _ref.max,\n      last = _ref.last,\n      _ref$first = _ref.first,\n      first = _ref$first === void 0 ? false : _ref$first;\n\n  if (first) {\n    last[0] = Math.round(Math.random() * (max - min)) + min;\n    return last[0];\n  }\n\n  last[1] = Math.round(Math.random() * (max - min)) + min;\n\n  if (last[1] != last[0]) {\n    last[0] = last[1];\n    return last[1];\n  } else {\n    return Random({\n      min: min,\n      max: max,\n      last: last\n    });\n  }\n}\n\nvar plugins = {\n  begin: 0,\n  install: function install(Vue, options) {\n    var defaultSrc = options.default;\n    Vue.directives('lazy', {\n      bind: function bind(el, binding) {\n        plugins.init(el, binding.value, defaultSrc);\n      },\n      inserted: function inserted(el) {}\n    });\n\n    Vue.prototype.throttle = function (fn, delay) {\n      var curTime = Date.now();\n\n      if (curTime - plugins.begin > delay) {\n        fn();\n        plugins.begin = curTime;\n      }\n    };\n  },\n  init: function init(el, val, def) {\n    el.setAttribute('data-src', val);\n    el.setAttribute('src', val);\n  },\n  ovserver: function ovserver(el) {\n    var io = new IntersectionObserver(function (entries) {\n      var realSrc = el.dataset.src;\n\n      if (entries[0].isIntersecting) {\n        if (realSrc) {\n          el.src = realSrc;\n          el.removeAttribute(\"data-src\");\n        }\n      }\n    });\n  }\n};\n\nfunction jsonpToJson(datas) {\n  var jsonData = null;\n  console.log(datas); // 下面是对获取到的数据进行处理，把jsonp格式的数据处理成json格式的数据\n\n  if (typeof datas === 'string') {\n    // 返回的是jsonp类型的数据，所以要用正则表达式来匹配截取json数据\n    var reg = /^\\w+\\((\\{[^()]+\\})\\)$/;\n    var matches = datas.match(reg); // matches匹配到的是数组，数组第一个是所有正则表达式匹配的字符串，第二个是第一个小括号匹配到的字符串\n\n    if (matches) {\n      jsonData = JSON.parse(matches[1]);\n    }\n  }\n\n  return jsonData;\n} //  function findscroller(element){\n//     element.onscroll = function(){ console.log(element);}\n//     Array.from(element.children).forEach(findscroller)\n// }\n// findscroller(document.body)\n\n\nvar query = function query(selector) {\n  return Array.from(document.querySelectorAll(selector));\n};\n\nexport { Random, plugins, jsonpToJson, query };","map":{"version":3,"sources":["C:/Users/Lisp/Desktop/items/src/utils/toolFn.js"],"names":["Random","min","max","last","first","Math","round","random","plugins","begin","install","Vue","options","defaultSrc","default","directives","bind","el","binding","init","value","inserted","prototype","throttle","fn","delay","curTime","Date","now","val","def","setAttribute","ovserver","io","IntersectionObserver","entries","realSrc","dataset","src","isIntersecting","removeAttribute","jsonpToJson","datas","jsonData","console","log","reg","matches","match","JSON","parse","query","selector","Array","from","document","querySelectorAll"],"mappings":";;;;;AACA,SAASA,MAAT,OAA6C;AAAA,MAA5BC,GAA4B,QAA5BA,GAA4B;AAAA,MAAvBC,GAAuB,QAAvBA,GAAuB;AAAA,MAAnBC,IAAmB,QAAnBA,IAAmB;AAAA,wBAAdC,KAAc;AAAA,MAAdA,KAAc,2BAAR,KAAQ;;AAEzC,MAAGA,KAAH,EAAS;AACLD,IAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUE,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,MAAiBL,GAAG,GAAGD,GAAvB,CAAX,IAA0CA,GAApD;AACA,WAAOE,IAAI,CAAC,CAAD,CAAX;AACH;;AAEDA,EAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUE,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,MAAiBL,GAAG,GAAGD,GAAvB,CAAX,IAA0CA,GAApD;;AAEA,MAAGE,IAAI,CAAC,CAAD,CAAJ,IAASA,IAAI,CAAC,CAAD,CAAhB,EAAoB;AAChBA,IAAAA,IAAI,CAAC,CAAD,CAAJ,GAAQA,IAAI,CAAC,CAAD,CAAZ;AACA,WAAOA,IAAI,CAAC,CAAD,CAAX;AACH,GAHD,MAGK;AACD,WAAOH,MAAM,CAAC;AAACC,MAAAA,GAAG,EAAHA,GAAD;AAAKC,MAAAA,GAAG,EAAHA,GAAL;AAASC,MAAAA,IAAI,EAAJA;AAAT,KAAD,CAAb;AACH;AAEJ;;AAED,IAAMK,OAAO,GAAG;AACZC,EAAAA,KAAK,EAAC,CADM;AAEZC,EAAAA,OAFY,mBAEJC,GAFI,EAEAC,OAFA,EAEQ;AAChB,QAAMC,UAAU,GAAGD,OAAO,CAACE,OAA3B;AAEAH,IAAAA,GAAG,CAACI,UAAJ,CAAe,MAAf,EAAsB;AAClBC,MAAAA,IADkB,gBACbC,EADa,EACVC,OADU,EACF;AACZV,QAAAA,OAAO,CAACW,IAAR,CAAaF,EAAb,EAAgBC,OAAO,CAACE,KAAxB,EAA8BP,UAA9B;AACH,OAHiB;AAIlBQ,MAAAA,QAJkB,oBAITJ,EAJS,EAIN,CAEX;AANiB,KAAtB;;AASAN,IAAAA,GAAG,CAACW,SAAJ,CAAcC,QAAd,GAAyB,UAASC,EAAT,EAAYC,KAAZ,EAAkB;AACvC,UAAIC,OAAO,GAAGC,IAAI,CAACC,GAAL,EAAd;;AACA,UAAGF,OAAO,GAAGlB,OAAO,CAACC,KAAlB,GAA0BgB,KAA7B,EAAmC;AAC/BD,QAAAA,EAAE;AACFhB,QAAAA,OAAO,CAACC,KAAR,GAAgBiB,OAAhB;AACH;AAEJ,KAPD;AASH,GAvBW;AAwBZP,EAAAA,IAxBY,gBAwBPF,EAxBO,EAwBJY,GAxBI,EAwBAC,GAxBA,EAwBI;AACZb,IAAAA,EAAE,CAACc,YAAH,CAAgB,UAAhB,EAA2BF,GAA3B;AACAZ,IAAAA,EAAE,CAACc,YAAH,CAAgB,KAAhB,EAAsBF,GAAtB;AACH,GA3BW;AA4BZG,EAAAA,QA5BY,oBA4BHf,EA5BG,EA4BA;AACR,QAAIgB,EAAE,GAAG,IAAIC,oBAAJ,CAA0B,UAAAC,OAAO,EAAE;AACxC,UAAMC,OAAO,GAAGnB,EAAE,CAACoB,OAAH,CAAWC,GAA3B;;AACA,UAAGH,OAAO,CAAC,CAAD,CAAP,CAAWI,cAAd,EAA6B;AACzB,YAAGH,OAAH,EAAW;AACPnB,UAAAA,EAAE,CAACqB,GAAH,GAASF,OAAT;AACAnB,UAAAA,EAAE,CAACuB,eAAH,CAAmB,UAAnB;AACH;AACJ;AACJ,KARQ,CAAT;AASH;AAtCW,CAAhB;;AAyCA,SAASC,WAAT,CAAsBC,KAAtB,EAA6B;AACzB,MAAIC,QAAQ,GAAG,IAAf;AACAC,EAAAA,OAAO,CAACC,GAAR,CAAYH,KAAZ,EAFyB,CAGzB;;AACA,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B;AACA,QAAMI,GAAG,GAAG,uBAAZ;AACA,QAAMC,OAAO,GAAGL,KAAK,CAACM,KAAN,CAAYF,GAAZ,CAAhB,CAH6B,CAI7B;;AACA,QAAIC,OAAJ,EAAa;AACXJ,MAAAA,QAAQ,GAAGM,IAAI,CAACC,KAAL,CAAWH,OAAO,CAAC,CAAD,CAAlB,CAAX;AACD;AACF;;AACD,SAAOJ,QAAP;AACD,C,CAGH;AACA;AAEA;AACA;AAEA;;;AAEA,IAAMQ,KAAK,GAAG,SAARA,KAAQ,CAASC,QAAT,EAAkB;AAC5B,SAAOC,KAAK,CAACC,IAAN,CAAWC,QAAQ,CAACC,gBAAT,CAA0BJ,QAA1B,CAAX,CAAP;AACH,CAFD;;AAIA,SAASpD,MAAT,EAAkBQ,OAAlB,EAA0BiC,WAA1B,EAAsCU,KAAtC","sourcesContent":["\r\nfunction Random({min, max,last,first=false}) {\r\n\r\n    if(first){\r\n        last[0] = Math.round(Math.random() * (max - min)) + min;\r\n        return last[0]\r\n    }\r\n    \r\n    last[1] = Math.round(Math.random() * (max - min)) + min;\r\n\r\n    if(last[1]!=last[0]){\r\n        last[0]=last[1]\r\n        return last[1]\r\n    }else{\r\n        return Random({min,max,last})\r\n    }\r\n    \r\n}\r\n\r\nconst plugins = {\r\n    begin:0,\r\n    install(Vue,options){\r\n        const defaultSrc = options.default\r\n\r\n        Vue.directives('lazy',{\r\n            bind(el,binding){\r\n                plugins.init(el,binding.value,defaultSrc)\r\n            },\r\n            inserted(el){\r\n                \r\n            }\r\n        })\r\n       \r\n        Vue.prototype.throttle = function(fn,delay){\r\n            let curTime = Date.now();\r\n            if(curTime - plugins.begin > delay){\r\n                fn()\r\n                plugins.begin = curTime\r\n            }\r\n\r\n        }\r\n\r\n    },\r\n    init(el,val,def){\r\n        el.setAttribute('data-src',val)\r\n        el.setAttribute('src',val)\r\n    },\r\n    ovserver(el){\r\n        let io = new IntersectionObserver( entries=>{\r\n            const realSrc = el.dataset.src\r\n            if(entries[0].isIntersecting){\r\n                if(realSrc){\r\n                    el.src = realSrc\r\n                    el.removeAttribute(\"data-src\")\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n}\r\nfunction jsonpToJson (datas) {\r\n    let jsonData = null\r\n    console.log(datas);\r\n    // 下面是对获取到的数据进行处理，把jsonp格式的数据处理成json格式的数据\r\n    if (typeof datas === 'string') {            \r\n      // 返回的是jsonp类型的数据，所以要用正则表达式来匹配截取json数据\r\n      const reg = /^\\w+\\((\\{[^()]+\\})\\)$/\r\n      const matches = datas.match(reg)\r\n      // matches匹配到的是数组，数组第一个是所有正则表达式匹配的字符串，第二个是第一个小括号匹配到的字符串\r\n      if (matches) {\r\n        jsonData = JSON.parse(matches[1])\r\n      }\r\n    }\r\n    return jsonData\r\n  }\r\n\r\n\r\n//  function findscroller(element){\r\n//     element.onscroll = function(){ console.log(element);}\r\n    \r\n//     Array.from(element.children).forEach(findscroller)\r\n// }\r\n\r\n// findscroller(document.body)\r\n\r\nconst query = function(selector){\r\n    return Array.from(document.querySelectorAll(selector))\r\n}\r\n\r\nexport { Random , plugins,jsonpToJson,query}\r\n\r\n"]},"metadata":{},"sourceType":"module"}